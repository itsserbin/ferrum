# Code Quality Analysis Scratchpad: Ferrum Terminal Emulator

Task: Architecture quality, code readability, function sizes analysis
Created: 2026-02-15
Language: Ukrainian (final report)

---

## Files Analyzed

1. src/main.rs (7 lines)
2. src/core/mod.rs (137 lines)
3. src/core/terminal.rs (584 lines)
4. src/gui/mod.rs (269 lines)
5. src/gui/renderer.rs (160 lines)
6. src/pty/mod.rs (63 lines)

Total: 1220 lines of code

---

## Detailed Analysis by File

### 1. src/main.rs (7 lines)
**Status**: EXCELLENT
- Single responsibility: entry point
- No issues
- Perfect example of KISS principle

### 2. src/core/mod.rs (137 lines)
**Status**: GOOD

Functions analyzed:
- `Color::WHITE`, `Color::BLACK` constants (lines 17-18): 1 line each - OK
- `Cell::default()` (lines 28-36): 8 lines - OK
- `Grid::new()` (lines 45-51): 6 lines - OK
- `Grid::get()` (lines 53-55): 2 lines - OK
- `Grid::set()` (lines 57-61): 4 lines - OK
- `Grid::put_str()` (lines 63-69): 6 lines - OK
- `Grid::resized()` (lines 71-79): 8 lines - OK
- `Grid::row_cells()` (lines 82-84): 2 lines - OK
- `Grid::shift_up()` (lines 89-105): **16 lines** - Borderline, but OK (simple loop logic)
- `Grid::shift_down()` (lines 110-125): **15 lines** - OK
- `Grid::set_row()` (lines 128-136): 8 lines - OK

**Issues**: NONE
**Observations**:
- Clean separation of data structures
- All functions are short and focused
- Good single responsibility

### 3. src/core/terminal.rs (584 lines)
**Status**: CRITICAL ISSUES

Functions analyzed:
- `Terminal::new()` (lines 22-37): 15 lines - OK
- `Terminal::process()` (lines 39-43): 4 lines - OK
- `Terminal::resize()` (lines 45-97): **52 LINES** - TOO LONG! Does too many things
- `Terminal::is_alt_screen()` (lines 100-102): 2 lines - OK
- `Terminal::build_display()` (lines 106-127): 21 lines - OK
- `Terminal::scroll_up_region()` (lines 129-150): 21 lines - OK
- `Terminal::scroll_down_region()` (lines 152-162): 10 lines - OK
- `Terminal::param()` (lines 164-170): 6 lines - OK
- `Terminal::enter_alt_screen()` (lines 173-181): 8 lines - OK
- `Terminal::leave_alt_screen()` (lines 184-190): 6 lines - OK
- `Perform::print()` (lines 194-230): **36 lines** - BORDERLINE, but complex logic
- `Perform::execute()` (lines 232-261): **29 lines** - OK but could be cleaner
- `Perform::csi_dispatch()` (lines 268-570): **302 LINES!!!** - MONSTER FUNCTION! CRITICAL!

**CRITICAL ISSUES**:

1. **`csi_dispatch()` (lines 268-570): 302 lines**
   - Does EVERYTHING: SGR colors, cursor movement, inline editing, scroll regions, insert/delete, clearing
   - MASSIVE match statement with 20+ different operations
   - Color assignment repeated 30+ times (lines 284-410)
   - MUST BE SPLIT INTO SEPARATE FUNCTIONS

2. **`resize()` (lines 45-97): 52 lines**
   - Handles 4 different scenarios: vertical shrink, resize, vertical grow, alt screen
   - Too many responsibilities
   - Should be split into smaller helper functions

3. **`print()` (lines 194-230): 36 lines**
   - Handles character width, wrapping, scrolling, wide character padding
   - Could be cleaner with helper functions

**Refactoring Priority**: HIGHEST

### 4. src/gui/mod.rs (269 lines)
**Status**: ISSUES

Functions analyzed:
- `App::new()` (lines 38-51): 13 lines - OK
- `ApplicationHandler::resumed()` (lines 55-102): **47 lines** - TOO LONG
- `ApplicationHandler::window_event()` (lines 104-212): **108 LINES!!!** - MONSTER FUNCTION
- `ApplicationHandler::about_to_wait()` (lines 214-234): 20 lines - OK
- `key_to_bytes()` (lines 237-262): 25 lines - OK
- `run()` (lines 264-268): 4 lines - OK

**CRITICAL ISSUES**:

1. **`window_event()` (lines 104-212): 108 lines**
   - Giant match statement handling 7 different event types
   - Each case is 10-40 lines long
   - Mixes concerns: keyboard input, scrolling, resize, rendering
   - MUST BE SPLIT into separate handler methods

2. **`resumed()` (lines 55-102): 47 lines**
   - Initializes window, PTY, spawns thread
   - Should be split: init_window(), init_pty(), spawn_reader_thread()

**Refactoring Priority**: HIGH

### 5. src/gui/renderer.rs (160 lines)
**Status**: GOOD

Functions analyzed:
- `Renderer::new()` (lines 17-34): 17 lines - OK
- `Renderer::render()` (lines 36-56): 20 lines - OK
- `Renderer::draw_cursor()` (lines 58-91): 33 lines - OK (mostly loop boilerplate)
- `Renderer::draw_bg()` (lines 93-116): 23 lines - OK (mostly loop boilerplate)
- `Renderer::draw_char()` (lines 118-154): 36 lines - OK (glyph rendering logic)
- `color_to_pixel()` (lines 157-159): 2 lines - OK

**Issues**: MINOR
**Observations**:
- Functions are reasonable size
- Some repetition in nested loops (draw_cursor, draw_bg) but acceptable
- Could extract loop boilerplate but not critical

### 6. src/pty/mod.rs (63 lines)
**Status**: EXCELLENT

Functions analyzed:
- `Session::spawn()` (lines 16-37): 21 lines - OK
- `Session::reader()` (lines 40-42): 2 lines - OK
- `Session::writer()` (lines 45-47): 2 lines - OK
- `Session::resize()` (lines 49-57): 8 lines - OK
- `Session::is_alive()` (lines 60-62): 2 lines - OK

**Issues**: NONE
**Observations**: Perfect example of clean, focused code

---

## Architecture Analysis

### Module Structure: GOOD
```
ferrum/
├── main.rs              [Entry point - excellent]
├── core/
│   ├── mod.rs          [Data structures - excellent]
│   └── terminal.rs     [Terminal logic - needs refactoring]
├── gui/
│   ├── mod.rs          [Event handling - needs refactoring]
│   └── renderer.rs     [Rendering - good]
└── pty/
    └── mod.rs          [PTY wrapper - excellent]
```

**Strengths**:
- Clear separation: core (terminal logic), gui (windowing/rendering), pty (process)
- Good use of Rust modules
- Dependencies flow correctly: gui → core, gui → pty

**Weaknesses**:
- terminal.rs is bloated (584 lines, one 302-line function)
- gui/mod.rs mixes too many concerns

### Design Patterns: ACCEPTABLE
- VTE Parser trait implementation (Perform) - good use of trait
- Message passing with mpsc for PTY events - correct pattern
- Renderer with glyph cache - good optimization

---

## Complexity Metrics

### Functions > 40 lines (BLOATED):
1. **terminal.rs::csi_dispatch()**: 302 lines - CATASTROPHIC
2. **gui/mod.rs::window_event()**: 108 lines - CRITICAL
3. **terminal.rs::resize()**: 52 lines - TOO LONG
4. **gui/mod.rs::resumed()**: 47 lines - TOO LONG

### Functions 30-40 lines (BORDERLINE):
1. terminal.rs::print(): 36 lines - borderline
2. renderer.rs::draw_char(): 36 lines - acceptable (glyph logic)
3. renderer.rs::draw_cursor(): 33 lines - acceptable (mostly loops)

---

## Readability Issues

### 1. Massive switch statements
- **terminal.rs lines 284-410**: Color codes repeated 30+ times
- Should use: color mapping table or helper function

### 2. Nested logic without helper functions
- **terminal.rs::resize()**: 4 distinct sections without clear boundaries
- **gui/mod.rs::window_event()**: Event handling inline instead of delegated

### 3. Magic numbers
- terminal.rs line 254: `(self.cursor_col + 8) & !7` - tab alignment without comment
- terminal.rs lines 298-407: Raw RGB values without named constants

### 4. Comments in Ukrainian mixed with English code
- Inconsistent: lines 99, 129-139 in Ukrainian, rest in English
- Should standardize

---

## Refactoring Recommendations

### PRIORITY 1: terminal.rs::csi_dispatch() (CRITICAL)

**Problem**: 302-line function doing everything

**Solution**: Split into separate methods:
```rust
// Instead of giant match in csi_dispatch():
match action {
    'm' => self.handle_sgr(params),           // 130 lines → 10 lines
    'H' | 'f' => self.handle_cursor_position(params),
    'A' | 'B' | 'C' | 'D' | 'G' | 'd' => self.handle_cursor_move(action, params),
    'P' | '@' | 'X' => self.handle_inline_edit(action, params),
    'J' | 'K' => self.handle_erase(action, params),
    'r' | 'S' | 'T' => self.handle_scroll_region(action, params),
    'L' | 'M' => self.handle_insert_delete(action, params),
    _ => {}
}
```

**New methods to create**:
- `handle_sgr(&mut self, params: &Params)` - SGR color handling
- `handle_cursor_position(&mut self, params: &Params)` - H/f commands
- `handle_cursor_move(&mut self, action: char, params: &Params)` - A/B/C/D/G/d
- `handle_inline_edit(&mut self, action: char, params: &Params)` - P/@/X
- `handle_erase(&mut self, action: char, params: &Params)` - J/K
- `handle_scroll_region(&mut self, action: char, params: &Params)` - r/S/T
- `handle_insert_delete(&mut self, action: char, params: &Params)` - L/M

**Additional improvement**: Create color table
```rust
const ANSI_COLORS: [(u8, Color); 16] = [
    (30, Color { r: 0, g: 0, b: 0 }),
    (31, Color { r: 205, g: 0, b: 0 }),
    // ... etc
];
```

**Impact**: 302 lines → ~50 lines, much more readable

---

### PRIORITY 2: gui/mod.rs::window_event() (CRITICAL)

**Problem**: 108-line function with massive match handling all events

**Solution**: Extract event handlers:
```rust
impl App {
    fn window_event(&mut self, event_loop: &ActiveEventLoop, window_id: WindowId, event: WindowEvent) {
        match event {
            WindowEvent::CloseRequested => event_loop.exit(),
            WindowEvent::ModifiersChanged(m) => self.handle_modifiers_changed(m),
            WindowEvent::KeyboardInput { event, .. } => self.handle_keyboard_input(event),
            WindowEvent::MouseWheel { delta, .. } => self.handle_mouse_wheel(delta),
            WindowEvent::Resized(size) => self.handle_resize(size),
            WindowEvent::RedrawRequested => self.handle_redraw(),
            _ => (),
        }
    }

    fn handle_keyboard_input(&mut self, event: KeyEvent) { /* 20 lines */ }
    fn handle_mouse_wheel(&mut self, delta: MouseScrollDelta) { /* 25 lines */ }
    fn handle_resize(&mut self, size: PhysicalSize) { /* 15 lines */ }
    fn handle_redraw(&mut self) { /* 40 lines */ }
    fn handle_modifiers_changed(&mut self, m: Modifiers) { /* 2 lines */ }
}
```

**Impact**: 108 lines → 8 lines dispatch + 5 focused methods

---

### PRIORITY 3: terminal.rs::resize() (HIGH)

**Problem**: 52 lines handling 4 scenarios

**Solution**: Extract helpers:
```rust
fn resize(&mut self, rows: usize, cols: usize) {
    if rows < self.grid.rows && self.cursor_row >= rows {
        self.handle_vertical_shrink(rows);
    }

    self.grid = self.grid.resized(rows, cols);

    if rows > self.grid.rows && !self.is_alt_screen() && !self.scrollback.is_empty() {
        self.handle_vertical_grow(rows, self.grid.rows);
    }

    self.resize_alt_screen_if_needed(rows, cols);
    self.clamp_cursor(rows, cols);
    self.reset_scroll_region(rows);
}

fn handle_vertical_shrink(&mut self, new_rows: usize) { /* ... */ }
fn handle_vertical_grow(&mut self, new_rows: usize, old_rows: usize) { /* ... */ }
fn resize_alt_screen_if_needed(&mut self, rows: usize, cols: usize) { /* ... */ }
fn clamp_cursor(&mut self, rows: usize, cols: usize) { /* ... */ }
fn reset_scroll_region(&mut self, rows: usize) { /* ... */ }
```

**Impact**: 52 lines → ~12 lines main + 5 helpers (~8 lines each)

---

### PRIORITY 4: gui/mod.rs::resumed() (MEDIUM)

**Problem**: 47 lines doing window init, PTY init, thread spawn

**Solution**: Extract initialization:
```rust
fn resumed(&mut self, event_loop: &ActiveEventLoop) {
    if self.window.is_some() {
        return;
    }

    self.init_window(event_loop);
    self.init_pty();
    self.spawn_pty_reader();

    self.window.as_ref().unwrap().request_redraw();
}

fn init_window(&mut self, event_loop: &ActiveEventLoop) { /* 10 lines */ }
fn init_pty(&mut self) { /* 5 lines */ }
fn spawn_pty_reader(&mut self) { /* 25 lines */ }
```

**Impact**: 47 lines → 10 lines main + 3 helpers

---

## Additional Improvements (Lower Priority)

### 1. terminal.rs::print() - extract helpers
```rust
fn print(&mut self, c: char) {
    let width = UnicodeWidthChar::width(c).unwrap_or(1);

    self.handle_line_wrap_if_needed(width);
    self.write_character(c, width);
    self.handle_wide_char_padding(c, width);

    self.cursor_col += width;
}
```

### 2. Create constants module for colors
```rust
// src/core/colors.rs
pub const ANSI_BLACK: Color = Color { r: 0, g: 0, b: 0 };
pub const ANSI_RED: Color = Color { r: 205, g: 0, b: 0 };
// ... etc
```

### 3. Standardize comments language
- Either all English or all Ukrainian
- Currently mixed

### 4. Extract magic numbers
```rust
const TAB_WIDTH: usize = 8;
const MAX_SCROLLBACK: usize = 1000;
const DELETE_CHAR: u8 = 0x7f;
const ESCAPE_CHAR: u8 = 0x1b;
```

---

## Summary Statistics

### Files needing refactoring:
- **CRITICAL**: terminal.rs (1 monster function)
- **CRITICAL**: gui/mod.rs (1 monster function)
- **MEDIUM**: terminal.rs (2 more functions)
- **CLEAN**: core/mod.rs, renderer.rs, pty/mod.rs, main.rs

### Function size distribution:
- 1-10 lines: 28 functions ✓
- 11-20 lines: 12 functions ✓
- 21-30 lines: 8 functions ✓ (acceptable)
- 31-40 lines: 3 functions ⚠️ (borderline)
- 41-60 lines: 2 functions ❌ (too long)
- 100+ lines: 2 functions ❌❌❌ (catastrophic)

### Code quality by module:
- main.rs: A+
- pty/mod.rs: A+
- core/mod.rs: A
- gui/renderer.rs: A-
- gui/mod.rs: C- (needs work)
- core/terminal.rs: D (critical issues)

---

## Estimated Refactoring Effort

### Priority 1 (terminal.rs::csi_dispatch): 4-6 hours
- Split into 7 handler methods
- Create color table
- Test all ANSI sequences still work

### Priority 2 (gui/mod.rs::window_event): 2-3 hours
- Extract 5 event handler methods
- Verify all events still handled correctly

### Priority 3 (terminal.rs::resize): 2-3 hours
- Extract 5 helper methods
- Test resize scenarios (shrink, grow, alt screen)

### Priority 4 (gui/mod.rs::resumed): 1-2 hours
- Extract 3 initialization methods
- Verify startup sequence

**Total estimated effort**: 9-14 hours

**Recommendation**: Do Priority 1 and 2 first (most critical), then Priority 3-4 if time permits.
