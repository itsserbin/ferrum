# Code Exploration Scratchpad: Cursor/Input/Resize Synchronization Analysis

Task: Deep analysis of cursor, grid, input line, and resize synchronization issues
Created: 2026-02-17
Scratchpad ID: 041c3a00

---

## Problem Definition

### Analysis Questions
- Primary: What are the concrete desynchronization bugs between cursor position, grid state, input line tracking, and resize/reflow?
- Secondary:
  - How does cursor position get updated and by whom?
  - How does grid reflow affect cursor tracking?
  - Where is the "current input line" concept tracked?
  - What happens to cursor during resize operations?
  - Are there race conditions or ordering issues?

### Search Keywords
- Core domain terms: cursor, grid, reflow, resize, input_line, scroll
- Related feature names: terminal state, grid operations, PTY handling
- Likely file/folder patterns: core/terminal*, core/grid*, gui/events/pty*

### Success Criteria
- [ ] All cursor tracking locations identified with specific paths
- [ ] Grid reflow logic fully traced
- [ ] Input line tracking mechanisms documented
- [ ] Resize event flow mapped end-to-end
- [ ] Concrete desynchronization bugs identified with line numbers
- [ ] Integration points between components mapped

---

## Exploration Log

### Entry 1: Terminal Cursor State (Core Structure)
THOUGHT: Need to understand how cursor position is stored and accessed
ACTION: Read src/core/terminal.rs
OBSERVATION:
- File: src/core/terminal.rs:43-44
- Terminal struct has TWO cursor fields:
  - `cursor_row: usize` - main cursor row
  - `cursor_col: usize` - main cursor column
- Also has saved cursor positions:
  - `saved_cursor: (usize, usize)` - ESC 7/8 save/restore
  - `alt_saved_cursor: (usize, usize)` - separate for alt screen
- Grid stored as: `grid: Grid` (rows x cols)
- Confidence: HIGH
- Key Facts:
  - Cursor is NOT stored relative to any "input line"
  - Cursor is absolute grid coordinates (row, col)
  - No concept of "current input line" in terminal state

### Entry 2: Cursor Movement Handlers
THOUGHT: How does cursor position get updated during terminal output?
ACTION: Read src/core/terminal.rs:294-430 (Perform trait implementation)
OBSERVATION:
- File: src/core/terminal.rs:294-338 - print() function
- Line 297-306: When cursor reaches edge, wraps to next row:
  - Sets current row as `wrapped=true` (soft wrap)
  - Moves cursor_col to 0, cursor_row += 1
  - If cursor_row > scroll_bottom, scrolls up and stays at scroll_bottom
- Line 337: cursor advances by character width
- File: src/core/terminal.rs:340-371 - execute() function
- Line 342-350: LF/VT/FF moves cursor_row down, marks current row NOT wrapped
- Line 352-355: CR sets cursor_col to 0
- Line 356-360: Backspace decrements cursor_col
- Confidence: HIGH
- Key Finding: Cursor updates are IMMEDIATE during text processing

### Entry 3: CSI Cursor Commands
THOUGHT: How do escape sequences move the cursor?
ACTION: Read src/core/terminal/handlers/cursor.rs
OBSERVATION:
- File: src/core/terminal/handlers/cursor.rs:10-16
- CUP (Cursor Position): Sets cursor_row and cursor_col directly
- Line 14-15: Clamps to grid.rows-1 and grid.cols-1
- Other commands: CUU (up), CUD (down), CUF (right), CUB (left)
- All commands clamp to grid boundaries
- Confidence: HIGH
- Key Finding: CSI commands directly mutate cursor_row/cursor_col

### Entry 4: Grid Structure and Reflow
THOUGHT: How is grid data organized and what happens during resize?
ACTION: Read src/core/grid.rs
OBSERVATION:
- File: src/core/grid.rs:26-39
- Grid has: rows_data: Vec<Row>, rows: usize, cols: usize
- Each Row has: cells: Vec<Cell>, wrapped: bool
- wrapped=true means row continues on next row (soft wrap)
- wrapped=false means hard line break (newline)
- File: src/core/grid.rs:68-77 - resized() does simple copy without reflow
- File: src/core/grid.rs:89-123 - shift_up/shift_down operations
- Confidence: HIGH
- Key Facts:
  - Grid doesn't know about cursor
  - Wrapped flag is per-row state

### Entry 5: Resize Flow (Terminal -> PTY)
THOUGHT: What happens when window is resized?
ACTION: Read src/gui/events/redraw.rs:287-292, src/gui/tabs/manage.rs:70-81
OBSERVATION:
- File: src/gui/events/redraw.rs:287-292 - on_resized()
  - Calculates new (rows, cols) from window size
  - Sets pending_grid_resize = Some((rows, cols))
  - Defers actual resize until redraw
- File: src/gui/events/redraw.rs:269-273 - apply_pending_resize()
  - Takes pending_grid_resize and calls resize_all_tabs()
- File: src/gui/tabs/manage.rs:71-81 - resize_all_tabs()
  - Line 73-75: Skips if terminal already at target size
  - Line 76: Calls tab.terminal.resize(rows, cols)
  - Line 77-79: Calls tab.session.resize() to notify PTY
- Confidence: HIGH
- Key Finding: Resize is TWO-STEP process

### Entry 6: Terminal Resize Implementation
THOUGHT: What exactly happens inside terminal.resize()?
ACTION: Read src/core/terminal/grid_ops.rs:6-31, 105-169
OBSERVATION:
- File: src/core/terminal/grid_ops.rs:6-31 - resize() entry point
  - Line 7-9: Early return if size unchanged
  - Line 14-17: Alt screen uses simple resize (no reflow)
  - Line 20-24: Main screen: reflow if cols changed, else simple
  - Line 26-28: Resets scroll region to full screen
  - Line 30: Sets resize_at timestamp
- File: src/core/terminal/grid_ops.rs:105-169 - reflow_resize()
  - Line 113: Calculates cursor_offset BEFORE reflow
  - Line 116: Collects logical lines (unwraps soft-wrapped rows)
  - Line 119: Rewraps lines to new width
  - Line 122: Finds cursor position in rewrapped content
  - Line 164-168: Sets new cursor_row and cursor_col
- Confidence: HIGH
- Critical Finding: Cursor position calculation during reflow

### Entry 7: Cursor Offset Calculation
THOUGHT: How is cursor offset calculated before reflow?
ACTION: Read src/core/terminal/grid_ops.rs:218-242
OBSERVATION:
- File: src/core/terminal/grid_ops.rs:218-242 - calculate_cursor_offset()
  - Line 223-228: Counts all chars in scrollback (with newlines for hard wraps)
  - Line 231-237: Counts chars in grid rows before cursor_row
  - Line 239: Adds cursor_col
  - Result: Absolute character offset from start of scrollback+grid
- Confidence: HIGH
- Key Finding: This is CHARACTER-BASED offset, not line-based

### Entry 8: Cursor Position After Reflow
THOUGHT: How is new cursor position determined after rewrap?
ACTION: Read src/core/terminal/grid_ops.rs:171-216
OBSERVATION:
- File: src/core/terminal/grid_ops.rs:172-193 - offset_to_absolute_row()
  - Iterates through rewrapped rows counting characters
  - Finds which row contains the target offset
  - Accounts for wrapped vs non-wrapped rows
- File: src/core/terminal/grid_ops.rs:195-216 - offset_to_col()
  - Finds cursor row, calculates column within that row
  - Returns (target_offset - row_start_offset)
- File: src/core/terminal/grid_ops.rs:164-168 - Final assignment
  - cursor_row = new_cursor_row - scrollback_rows (to visible grid)
  - cursor_col = clamped to cols-1
- Confidence: HIGH
- Key Finding: Cursor tracking through reflow uses character offsets

### Entry 9: Scroll Region and Scrolling
THOUGHT: How do scroll regions affect cursor?
ACTION: Read src/core/terminal/handlers/scroll.rs, src/core/terminal/grid_ops.rs:365-408
OBSERVATION:
- File: src/core/terminal/handlers/scroll.rs:10-23 - DECSTBM
  - Sets scroll_top and scroll_bottom
  - LINE 20-21: RESETS cursor to (0, 0) ← IMPORTANT!
- File: src/core/terminal/grid_ops.rs:365-392 - scroll_up_region()
  - Line 367-377: Saves top row to scrollback if top==0 and not alt screen
  - Line 379-387: Shifts rows up within region
  - Does NOT adjust cursor position
- File: src/core/terminal/grid_ops.rs:394-408 - scroll_down_region()
  - Shifts rows down within region
  - Does NOT adjust cursor position
- Confidence: HIGH
- Key Finding: Scrolling moves grid content but NOT cursor

### Entry 10: PTY Data Flow
THOUGHT: How does PTY data reach the terminal and trigger cursor updates?
ACTION: Read src/gui/events/pty.rs:6-29
OBSERVATION:
- File: src/gui/events/pty.rs:8-29 - on_pty_event()
  - Line 10: tab.terminal.process(bytes) - THIS is where PTY output is parsed
  - Line 11: Resets scroll_offset to 0 (jumps to bottom)
  - Line 13-18: Handles scrollback_popped adjustments
  - No cursor manipulation here
- Confidence: HIGH
- Key Finding: PTY data processing is synchronous

### Entry 11: Simple Resize (Height-Only)
THOUGHT: What happens when only height changes?
ACTION: Read src/core/terminal/grid_ops.rs:33-64
OBSERVATION:
- File: src/core/terminal/grid_ops.rs:33-64 - simple_resize()
  - Line 39-53: Vertical shrink: if cursor_row >= new rows
    - Shifts rows to scrollback
    - Adjusts cursor_row by shift amount
  - Line 55: Calls grid.resized() (simple copy)
  - Line 62-63: Clamps cursor to new grid size
- Confidence: HIGH
- Key Finding: Simple resize can push content to scrollback

### Entry 12: No "Input Line" Concept
THOUGHT: Is there any tracking of "current input line" or prompt position?
ACTION: Grep for input_line, current_line, prompt
OBSERVATION:
- No matches found for input_line, current_line in codebase
- No tracking of prompt position
- No shell-aware state
- Confidence: HIGH
- Critical Finding: Terminal is DUMB - doesn't know about shell prompts or input

---

## Architecture Analysis

### Component Responsibilities

**Terminal (src/core/terminal.rs)**
- Owns: grid, cursor_row, cursor_col, scrollback, scroll region
- Does: VTE parsing, character printing, cursor movement, scrolling
- Pattern: State machine with mutable state
- Dependencies: Grid, VTE parser

**Grid (src/core/grid.rs)**
- Owns: rows_data (Vec<Row>), dimensions
- Does: Cell storage, row operations (shift, get, set)
- Pattern: Data structure with no knowledge of cursor
- Dependencies: Cell, Row

**FerrumWindow (src/gui/state.rs, src/gui/mod.rs)**
- Owns: tabs (Vec<TabState>), backend (renderer)
- Does: Window management, event routing, resize coordination
- Pattern: Event handler with tab multiplexing

**TabState (src/gui/state.rs)**
- Owns: terminal, session (PTY), scroll_offset, selection
- Does: Per-tab state management
- Pattern: Composition of terminal + PTY + UI state

**PTY (src/pty/mod.rs)**
- Owns: master PTY handle, child process
- Does: Process spawning, PTY I/O, resize notification
- Pattern: Thin wrapper over portable_pty

### Data Flow Layers

1. **Window resize event** (OS) →
2. **on_resized()** sets pending_grid_resize →
3. **on_redraw_requested()** calls apply_pending_resize() →
4. **resize_all_tabs()** iterates tabs →
5. **terminal.resize()** rewraps grid + updates cursor →
6. **session.resize()** notifies PTY of new size →
7. **Shell process** receives SIGWINCH/resize signal →
8. **Shell redraws** prompt/content →
9. **PTY reader** sends output bytes →
10. **on_pty_event()** calls terminal.process() →
11. **VTE parser** updates grid + cursor →
12. **Redraw** renders new state

### Cross-Cutting Concerns

**Cursor Position**
- Tracked in: Terminal.cursor_row, Terminal.cursor_col
- Updated by: print(), execute(), CSI handlers, resize reflow
- Used by: Renderer (drawing cursor), selection, hit testing

**Scrollback**
- Stored in: Terminal.scrollback (VecDeque<Row>)
- Grows when: scroll_up_region() at top, simple_resize() shrink
- Displayed via: build_display() when scroll_offset > 0

**Reflow State**
- Trigger: cols change in main screen
- Algorithm: Unwrap → character offset → rewrap → find cursor
- Issue: Character offset can desync if grid modified during resize

---

## Implementation Details

### Algorithm: Reflow Cursor Tracking

**Input:** Old cursor position (row, col), old grid, new width
**Output:** New cursor position (row, col) in rewrapped grid

**Steps:**
1. Calculate absolute character offset:
   - offset = sum(scrollback char counts) + sum(grid rows before cursor) + cursor_col
   - Account for newlines (hard wraps add +1)
2. Unwrap logical lines:
   - Combine rows where wrapped=true
3. Rewrap to new width:
   - Split logical lines at new column boundary
   - Mark continuation rows as wrapped=true
4. Find cursor row:
   - Scan rewrapped rows, count characters until offset reached
5. Find cursor col:
   - offset - row_start_offset
6. Adjust for scrollback split:
   - cursor_row -= scrollback_rows (to map to visible grid)

**Complexity:** O(total_rows * cols) - processes all content

**Edge Cases Handled:**
- Cursor past end of content → last row
- Offset at newline → stays on current row
- Very small new width → cursor clamped

**Edge Cases NOT Handled:**
- Grid modification during resize (no locking)
- PTY output arriving during reflow
- Wide characters at wrap boundary (partial handling)

### Error Handling

**Resize Errors:**
- PTY resize failure: Logged but doesn't block terminal resize
- Terminal and PTY can desync sizes

**Cursor Clamping:**
- All cursor movements clamp to grid boundaries
- CSI commands use saturating arithmetic
- Resize clamps cursor to new dimensions

**Scrollback Overflow:**
- Limited to max_scrollback (1000 rows)
- Old rows discarded with pop_front()
- Selection adjusted via scrollback_popped counter

### Performance

**Reflow is Expensive:**
- Full content scan on every column change
- Character offset calculation is O(rows * cols)
- Can cause jank on large scrollback

**Simple Resize is Fast:**
- Height-only changes use shift_up/shift_down
- O(rows) grid copy

**Cursor Updates are Immediate:**
- Every print() and execute() updates cursor
- No buffering or coalescing

---

## Desynchronization Issues Found

### BUG 1: Race Between PTY Output and Resize Reflow

**Location:** src/core/terminal/grid_ops.rs:113-122, src/gui/events/pty.rs:10

**Issue:**
1. Window resize triggers → pending_grid_resize set
2. PTY still sending output → terminal.process() modifying grid + cursor
3. Redraw calls apply_pending_resize() → reflow_resize() starts
4. Reflow calculates cursor_offset based on CURRENT grid state (line 113)
5. But PTY may have added/removed lines BETWEEN resize event and reflow
6. Cursor offset calculation is now WRONG

**Concrete Scenario:**
- Terminal has prompt at row 23, cursor at col 10
- User resizes window narrower
- Before reflow runs:
  - Shell receives SIGWINCH, redraws prompt
  - Clears screen (ESC[2J), moves cursor to top (ESC[H)
  - PTY output arrives, cursor now at row 0, col 0
- Reflow runs:
  - Calculates offset based on OLD position (was row 23, col 10)
  - Scrollback + grid now has different content
  - Finds wrong absolute_row for this offset
  - Cursor ends up in wrong position after reflow

**Evidence:**
- No locking between pty.rs:10 (process) and redraw.rs:308 (apply_pending_resize)
- Both mutate terminal.grid and terminal.cursor_*
- Reflow assumes grid is stable during calculation

**Impact:** Critical - cursor appears at wrong position after resize

---

### BUG 2: DECSTBM Resets Cursor Without Shell Knowledge

**Location:** src/core/terminal/handlers/scroll.rs:20-21

**Issue:**
1. Some applications set scroll margins with DECSTBM (ESC[<top>;<bottom>r)
2. DECSTBM resets cursor to (0, 0) per VT spec (line 20-21)
3. But shell/application doesn't know terminal did this
4. Application thinks cursor is still at previous position
5. Next output writes to wrong location

**Concrete Scenario:**
- Vim sets scroll region for split window
- Sends ESC[5;20r (rows 4-19 become scroll region)
- Terminal resets cursor to (0, 0)
- Vim sends "insert text" assuming cursor at (10, 15)
- Text appears at top of screen instead

**Evidence:**
```rust
// src/core/terminal/handlers/scroll.rs:20-21
term.cursor_row = 0;
term.cursor_col = 0;
```

**Impact:** High - breaks applications using scroll regions

---

### BUG 3: Scroll Operations Don't Update Cursor

**Location:** src/core/terminal/grid_ops.rs:365-408

**Issue:**
1. scroll_up_region() and scroll_down_region() move grid content
2. They do NOT adjust cursor position
3. If cursor was pointing at row X with content "ABC"
4. After scroll_up, content "ABC" is now at row X-1
5. But cursor still at row X, now pointing at different content

**Concrete Scenario:**
- Cursor at row 5, content is "$ ls"
- Scroll up by 1 (ESC[1S)
- Content shifts: row 5 now has what was row 6
- Cursor still at row 5, but "$ ls" moved to row 4
- Shell thinks cursor is on "$ ls" line
- Terminal thinks cursor is on row 5 (different line)

**Evidence:**
```rust
// src/core/terminal/grid_ops.rs:379-391
// Shifts rows but no cursor adjustment
for row in (top + 1)..=bottom {
    // Move row content up
}
// cursor_row unchanged
```

**Impact:** Medium - affects applications using scroll commands

---

### BUG 4: Simple Resize Cursor Adjustment Ignores Prompt Position

**Location:** src/core/terminal/grid_ops.rs:39-53

**Issue:**
1. When shrinking height, if cursor_row >= new rows
2. Code shifts rows to scrollback and adjusts cursor_row by shift amount
3. This assumes cursor should stay on "same content"
4. But shell prompt may have been redrawn at different position
5. Adjustment is based on OLD cursor position, not NEW shell state

**Concrete Scenario:**
- Terminal 40 rows, prompt at row 35, cursor at row 37
- Shrink to 20 rows
- simple_resize shifts 18 rows to scrollback (37 - 20 + 1 = 18)
- Sets cursor_row = 37 - 18 = 19 (bottom row)
- Meanwhile, shell gets SIGWINCH, redraws prompt at row 0
- Cursor should be at row 0, but terminal thinks it's at row 19

**Evidence:**
```rust
// src/core/terminal/grid_ops.rs:40-52
let shift = self.cursor_row - rows + 1;
// ... shift rows to scrollback ...
self.cursor_row -= shift;
```

**Impact:** High - cursor wrong after shrink resize

---

### BUG 5: Reflow Splits Scrollback/Grid Incorrectly

**Location:** src/core/terminal/grid_ops.rs:130-143

**Issue:**
1. After rewrap, code must split content into scrollback + visible grid
2. Algorithm tries to keep cursor visible
3. But if cursor_abs_row >= rows, it calculates:
   - scrollback_rows = cursor_abs_row - rows + 1
4. This puts cursor at bottom row ALWAYS on shrink
5. Loses context above cursor

**Concrete Scenario:**
- Long scrollback with 100 logical lines
- Cursor at line 80
- Shrink to 20 rows height
- Code sets scrollback_rows = 80 - 20 + 1 = 61
- Visible grid shows lines 61-80
- But shell may have cleared and put prompt at top
- User sees cursor at bottom with wrong content

**Evidence:**
```rust
// src/core/terminal/grid_ops.rs:130-133
let scrollback_rows = if cursor_abs_row >= rows {
    cursor_abs_row - rows + 1  // Forces cursor at bottom
} else if ...
```

**Impact:** Medium - bad scrollback split on resize

---

### BUG 6: No Input Line Tracking for Inline Editing

**Location:** Entire codebase - absence of feature

**Issue:**
1. Terminal doesn't track which row is "input line"
2. Shell prompt + user input may span multiple wrapped rows
3. Backspace, delete, insert operations work on current row only
4. But shell input line may have wrapped to multiple rows
5. No coordination between terminal's idea of "current row" and shell's input buffer

**Concrete Scenario:**
- User types long command that wraps to 3 rows
- Rows 10-12 contain: "echo this is a ve", "ry long command th", "at wraps"
- User hits backspace to delete "at wraps"
- Shell sends ESC[P (delete char) assuming cursor at end of row 12
- Terminal deletes at current cursor_col on cursor_row
- But may not match shell's expectation if wrap boundaries differ

**Evidence:**
- No input_line field in Terminal struct
- No prompt_row tracking
- Edit commands (DCH, ICH) operate on single row only

**Impact:** Medium - inline editing can desync with shell

---

### BUG 7: Cursor Offset Doesn't Account for Wide Characters

**Location:** src/core/terminal/grid_ops.rs:218-242

**Issue:**
1. calculate_cursor_offset counts cursor_col as character offset
2. But wide characters (CJK) occupy 2 columns
3. Cursor might be at col 5, but only 3 characters printed
4. Offset calculation treats col 5 as 5 characters
5. After reflow, cursor position is wrong

**Concrete Scenario:**
- Row contains: "漢字ab" (2 wide chars + 2 ascii = 6 cols)
- Cursor at col 6 (end of row)
- Offset calculated as row_start + 6
- After reflow, finds position 6 chars into content
- But content is only 4 characters
- Cursor placed past end of actual text

**Evidence:**
```rust
// src/core/terminal/grid_ops.rs:239
offset += self.cursor_col;  // Treats col as char count
```

**Impact:** High - breaks cursor position with wide characters

---

### BUG 8: Pending Resize Can Be Overwritten

**Location:** src/gui/state.rs:114, src/gui/events/redraw.rs:290

**Issue:**
1. pending_grid_resize is Option<(rows, cols)>
2. Multiple resize events can overwrite pending value
3. But if first resize triggered reflow calculation in progress...
4. Second resize overwrites pending_grid_resize
5. First reflow completes with stale dimensions

**Concrete Scenario:**
- User rapidly resizes window
- Resize event 1: pending = Some((20, 80))
- Resize event 2: pending = Some((25, 90)) (overwrites)
- Redraw processes: takes (25, 90), starts reflow
- But some state might have been based on (20, 80)

**Evidence:**
```rust
// src/gui/events/redraw.rs:290
self.pending_grid_resize = Some((rows, cols));  // Overwrites
```

**Impact:** Low - rare race condition

---

### BUG 9: Scrollback Popped Adjustment Race

**Location:** src/gui/events/pty.rs:13-18

**Issue:**
1. When scrollback pops old rows, counter is incremented
2. Selection adjusted by this counter
3. But adjustment happens AFTER terminal.process()
4. If process() modifies selection, adjustment is lost

**Evidence:**
```rust
// src/gui/events/pty.rs:13-18
let popped = tab.terminal.drain_scrollback_popped();
if popped > 0 {
    tab.selection = tab.selection.and_then(|sel| sel.adjust_for_scrollback_pop(popped));
}
```

**Impact:** Low - selection drift over time

---

### BUG 10: Alternate Screen Cursor Not Synced on Switch

**Location:** src/core/terminal/grid_ops.rs:411-436

**Issue:**
1. enter_alt_screen saves main cursor to alt_saved_cursor
2. Sets cursor to (0, 0) for alt screen
3. leave_alt_screen restores from alt_saved_cursor
4. But if shell sent cursor movements BEFORE alt screen sequence arrived...
5. Restored cursor position is from BEFORE those movements

**Concrete Scenario:**
- Shell moves cursor to (10, 5)
- Sends ESC[?1049h (enter alt screen)
- Terminal saves (10, 5) to alt_saved_cursor
- But network delay: shell had already moved cursor to (15, 20) in main screen
- Those movements were still in pipe
- Now in alt screen, cursor at (0, 0)
- Later exit alt screen: restores to (10, 5)
- Wrong! Should be (15, 20)

**Evidence:**
```rust
// src/core/terminal/grid_ops.rs:415
self.alt_saved_cursor = (self.cursor_row, self.cursor_col);
```

**Impact:** Low - timing dependent

---

## Summary of Critical Issues

### Desynchronization Root Causes

1. **No Locking Between PTY and Resize**
   - PTY output and resize both mutate terminal state
   - Race condition: reflow uses stale grid/cursor state

2. **Shell and Terminal Have Different State Models**
   - Shell tracks: prompt position, input buffer, cursor
   - Terminal tracks: grid, cursor (row, col), scroll region
   - No synchronization protocol between them

3. **Cursor Position is Coordinate-Based, Not Content-Based**
   - Cursor at (row, col) is position in grid
   - When grid content moves (scroll, reflow), cursor doesn't follow
   - Shell expects cursor to follow content

4. **Reflow Algorithm Assumes Static State**
   - Character offset calculation during reflow
   - Assumes grid hasn't changed since resize trigger
   - Violated by concurrent PTY output

5. **No "Input Line" or "Prompt" Awareness**
   - Terminal doesn't know which row is user input
   - Can't preserve input line position across resize
   - Can't validate cursor is on input line

### Affected Use Cases

**Most Broken:**
- Resize window during active typing → cursor wrong position
- Narrow window with wrapped input → backspace/edit breaks
- Applications using scroll regions → cursor jumps
- Shell redraws during resize → prompt misaligned

**Moderately Broken:**
- Wide characters in input → cursor offset wrong
- Rapid resize → occasional glitch
- Alt screen apps → cursor restore drift

**Works OK:**
- Static content display
- Full screen apps that manage own layout
- Simple typing without resize
