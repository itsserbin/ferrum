# Code Exploration Scratchpad: Mouse Click Event Handling

Task: Understanding why clicks don't work in Ferrum terminal
Created: 2026-02-16

---

## Problem Definition

### Analysis Questions
- Primary: Why don't mouse clicks work in the terminal?
- Secondary:
  - How are mouse events captured from winit?
  - How are they translated to terminal coordinates?
  - Are they sent to the PTY child process?
  - Does selection logic interfere?
  - Are there coordinate conversion issues?

### Search Keywords
- Core domain terms: mouse, click, button, cursor, event
- Related feature names: selection, input, interaction, MouseButton
- Likely file/folder patterns: gui/events, gui/input, gui/interaction, core/selection

### Success Criteria
- [ ] All mouse event handling files identified with specific paths
- [ ] Complete event flow from winit to PTY documented
- [ ] Key interfaces and functions documented
- [ ] Integration points mapped
- [ ] Root cause(s) of broken clicks identified

---

## Exploration Log

### Entry 1: Entry Point - winit Event Handling
THOUGHT: Mouse events come through winit's ApplicationHandler trait. Need to find the entry point.
ACTION: Read /home/user/apps/ferrum/src/gui/lifecycle.rs
OBSERVATION:
- File: src/gui/lifecycle.rs:99-101
- ApplicationHandler::window_event handles WindowEvent::MouseInput
- Calls self.on_mouse_input(event_loop, state, button)
- Confidence: High
- Key Facts: All mouse button events route through on_mouse_input

### Entry 2: Mouse Input Dispatcher
THOUGHT: on_mouse_input must dispatch to left/middle/right button handlers
ACTION: Read /home/user/apps/ferrum/src/gui/events/mouse/input.rs
OBSERVATION:
- File: src/gui/events/mouse/input.rs:5-17
- on_mouse_input dispatches based on button type
- Left button -> on_left_mouse_input
- Middle button -> on_middle_mouse_input
- Right button -> on_right_mouse_input
- Confidence: High

### Entry 3: Left Click Handler
THOUGHT: Need to trace left click flow - what conditions are checked?
ACTION: Read /home/user/apps/ferrum/src/gui/events/mouse/input.rs:92-113
OBSERVATION:
- File: src/gui/events/mouse/input.rs:92-113
- on_left_mouse_input checks multiple conditions IN ORDER:
  1. Line 96: cancel_rename_if_blurred_by_click (only on Pressed)
  2. Line 99: handle_context_menu_left_click - returns early if handled
  3. Line 103: if my < TAB_BAR_HEIGHT -> handle_tab_bar_left_click, returns early
  4. Line 108: handle_resize_left_click - returns early if handled
  5. Line 112: handle_terminal_left_click - ONLY if all above fail
- Confidence: High
- KEY FINDING: Terminal clicks ONLY happen if not in tab bar, context menu, or resize zones

### Entry 4: Terminal Click Handler
THOUGHT: What happens in handle_terminal_left_click?
ACTION: Read /home/user/apps/ferrum/src/gui/events/mouse/terminal_click.rs
OBSERVATION:
- File: src/gui/events/mouse/terminal_click.rs:22-108
- Line 29: Converts pixel coords to grid coords via pixel_to_grid
- Line 32-46: If mouse_reporting mode is active, sends mouse events to PTY
- Line 48-107: Shell mode (no mouse reporting) - handles selection and click-to-cursor
- Pressed event (line 56-91):
  - Sets is_selecting = true
  - Handles Shift+click for extending selection
  - Single click: arms char-wise drag, NO selection yet
  - Double click: selects word
  - Triple click: selects line
- Released event (line 93-106):
  - Line 94-95: determines if should move cursor (only if no drag happened)
  - Line 98-104: If should_move_cursor, calls move_cursor_to
  - Line 99-101: suppress_click_to_cursor_once check - SKIPS cursor move if true!
- Confidence: High
- KEY FINDING: Click-to-cursor ONLY happens on release, ONLY if no selection, and NOT if suppress flag is set

### Entry 5: Suppress Flag Investigation
THOUGHT: What sets suppress_click_to_cursor_once? This might be the bug!
ACTION: Grep for suppress_click_to_cursor_once in lifecycle.rs and cursor.rs
OBSERVATION:
- File: src/gui/lifecycle.rs:77
- Set to true in WindowEvent::Focused(true) handler
- Comment: "First click after refocus may use stale cursor position"
- File: src/gui/events/mouse/cursor.rs:7
- Set to false in on_cursor_moved
- File: src/gui/mod.rs:59
- Initialized to false in App::new()
- Confidence: High
- KEY FINDING: Flag is set on window focus, cleared on cursor move

### Entry 6: Focus Event Analysis
THOUGHT: When does the focus event fire? Does it fire when clicking the window?
ACTION: Analyze src/gui/lifecycle.rs:63-81
OBSERVATION:
- File: src/gui/lifecycle.rs:63-81
- WindowEvent::Focused fires when window gains/loses focus
- On focus gain (line 75-80):
  - Sets suppress_click_to_cursor_once = true (line 77)
  - Comment says "First click after refocus may use stale cursor position"
- This flag is CLEARED in on_cursor_moved (line 7 in cursor.rs)
- BUT: MouseInput event may fire BEFORE CursorMoved event!
- Confidence: High
- CRITICAL BUG IDENTIFIED: suppress flag may be true during first click

### Entry 7: Event Order Investigation
THOUGHT: What's the event order? Does CursorMoved always fire before MouseInput?
ACTION: Analyze winit event flow
OBSERVATION:
- Winit may send events in this order:
  1. Focused(true) - sets suppress_click_to_cursor_once = true
  2. CursorMoved - sets suppress_click_to_cursor_once = false
  3. MouseInput (Pressed)
  4. MouseInput (Released) - checks suppress flag
- BUT: If user clicks without moving mouse, CursorMoved might not fire!
- Or CursorMoved fires with SAME position, still clearing the flag
- Actually, CursorMoved DOES clear the flag (line 7 of cursor.rs)
- Confidence: Medium
- HYPOTHESIS: The suppress mechanism should work IF CursorMoved fires

### Entry 8: Cursor Movement Implementation
THOUGHT: How does move_cursor_to work? Does it actually send to PTY?
ACTION: Read /home/user/apps/ferrum/src/gui/interaction/cursor_move.rs
OBSERVATION:
- File: src/gui/interaction/cursor_move.rs:7-70
- Line 8-10: Gets active tab or returns early
- Line 13-15: Gets current cursor position and alt_screen state
- Line 19-49: In alt-screen mode, sends arrow key sequences for vertical + horizontal
- Line 50-64: In shell mode, ONLY allows horizontal moves on same row (line 52-54)
- Line 66-69: Writes bytes to pty_writer and flushes
- Confidence: High
- KEY FINDING: Click-to-cursor works by sending arrow key escape sequences to PTY

### Entry 9: Mouse Reporting Mode
THOUGHT: What is mouse_reporting mode and when is it active?
ACTION: Read /home/user/apps/ferrum/src/gui/interaction/mouse_reporting.rs
OBSERVATION:
- File: src/gui/interaction/mouse_reporting.rs:22-27
- is_mouse_reporting returns true if:
  - Terminal has mouse_mode != MouseMode::Off
  - AND Shift is NOT pressed (Shift overrides to local selection)
- Line 6-19: send_mouse_event encodes and sends mouse events to PTY
- Uses encode_mouse_event from input.rs
- Confidence: High
- KEY FINDING: Apps like vim can request mouse reporting mode

### Entry 10: Coordinate Conversion
THOUGHT: How are pixel coordinates converted to terminal grid coordinates?
ACTION: Read /home/user/apps/ferrum/src/gui/interaction/geometry.rs
OBSERVATION:
- File: src/gui/interaction/geometry.rs:6-18
- pixel_to_grid subtracts WINDOW_PADDING from x, TAB_BAR_HEIGHT+PADDING from y
- Divides by cell_width and cell_height
- Clamps to grid bounds (min/max row/col)
- Confidence: High
- No issues found in coordinate conversion

### Entry 11: Selection Drag Update
THOUGHT: Does selection interfere with click-to-cursor?
ACTION: Read /home/user/apps/ferrum/src/gui/interaction/selection.rs
OBSERVATION:
- File: src/gui/interaction/selection.rs:81-159
- update_drag_selection is called on cursor move while is_selecting is true
- Line 99-101: If Character mode, current == anchor, and no existing selection, returns early
- This means: single click without drag leaves selection as None
- Confidence: High
- KEY FINDING: Selection logic is correct - doesn't interfere with click-to-cursor

---

## ROOT CAUSE ANALYSIS

### Bug #1: suppress_click_to_cursor_once Logic Issue

**Location**: src/gui/lifecycle.rs:77 + src/gui/events/mouse/terminal_click.rs:99-101

**The Problem**:
The `suppress_click_to_cursor_once` flag is set to `true` when the window gains focus (line 77 in lifecycle.rs) to prevent the first click after refocus from moving the cursor with a "stale" cursor position.

However, this creates a bug:
1. User clicks on the terminal window to give it focus
2. WindowEvent::Focused(true) fires -> sets suppress_click_to_cursor_once = true
3. WindowEvent::CursorMoved fires -> sets suppress_click_to_cursor_once = false
4. WindowEvent::MouseInput(Pressed) -> arms selection
5. WindowEvent::MouseInput(Released) -> checks suppress flag
   - Flag should be false if CursorMoved fired
   - BUT if there's ANY timing issue or if CursorMoved doesn't fire, flag stays true
   - Result: click-to-cursor is suppressed!

**Evidence**:
- Line 77 in lifecycle.rs: Sets flag on focus
- Line 7 in cursor.rs: Clears flag on cursor move
- Line 99-101 in terminal_click.rs: Suppresses cursor move if flag is true

**Why This Is Wrong**:
The suppression should only apply to the FIRST click after window refocus, but the mechanism is fragile:
- It assumes CursorMoved always fires before MouseInput
- It assumes the suppress flag is checked on the SAME click that caused focus
- In practice, if user clicks to focus and the click goes through the full Pressed->Released cycle, the flag might still be true when Released fires

### Bug #2: No Clear Indication of Click Handling

**Location**: Multiple files in src/gui/events/mouse/

**The Problem**:
There's no logging or debugging output to understand what's happening with clicks. When clicks don't work, users (and developers) have no visibility into:
- Which handler consumed the event
- Whether coordinates are correct
- Whether the suppress flag is active
- Whether mouse_reporting mode is interfering

---

## Architecture Analysis

### Event Flow: Mouse Click to PTY

```
winit::WindowEvent::MouseInput
  ↓
ApplicationHandler::window_event (lifecycle.rs:99-101)
  ↓
App::on_mouse_input (events/mouse/input.rs:5-17)
  ↓ [dispatch by button]
  ↓
App::on_left_mouse_input (events/mouse/input.rs:92-113)
  ↓ [early returns for non-terminal areas]
  ↓
App::handle_terminal_left_click (events/mouse/terminal_click.rs:22-108)
  ↓ [check mouse_reporting mode]
  ├─ Yes: send_mouse_event → PTY (interaction/mouse_reporting.rs:6-19)
  └─ No: Handle selection + click-to-cursor
      ↓ [on Released, if no drag]
      ↓
App::move_cursor_to (interaction/cursor_move.rs:7-70)
  ↓ [generate arrow key sequences]
  ↓
tab.pty_writer.write_all(&bytes) (cursor_move.rs:67-68)
```

### Layers
1. **Event Layer** (lifecycle.rs): Receives winit events
2. **Dispatch Layer** (events/mouse/input.rs): Routes to specific handlers
3. **Handler Layer** (events/mouse/terminal_click.rs): Implements click logic
4. **Interaction Layer** (interaction/*): Coordinate conversion, cursor movement, selection
5. **PTY Layer** (pty/mod.rs): Sends bytes to child process

---

## Implementation Details

### Critical Variables

| Variable | Location | Purpose |
|----------|----------|---------|
| `suppress_click_to_cursor_once` | state.rs:68 | Prevents cursor move on first click after focus |
| `is_selecting` | state.rs:53 | Tracks if mouse is currently pressed (drag mode) |
| `selection_anchor` | state.rs:59 | Starting point of selection |
| `click_streak` | state.rs:58 | 1=single, 2=double, 3=triple click |
| `mouse_mode` | terminal.rs:60 | Whether terminal requests mouse events (vim, tmux) |

### Flags That Suppress Click-to-Cursor

1. **suppress_click_to_cursor_once** (line 99-101 in terminal_click.rs)
   - Set on window focus
   - Cleared on cursor move
   - PROBLEM: May stay true during click

2. **selection exists** (line 94-95 in terminal_click.rs)
   - If user dragged to create selection, don't move cursor
   - This is CORRECT behavior

3. **mouse_reporting mode active** (line 32-46 in terminal_click.rs)
   - If terminal app requested mouse events, send to app instead
   - This is CORRECT behavior (vim needs mouse events)

4. **click not in terminal area** (line 103-106 in input.rs)
   - Clicks in tab bar or context menu don't reach terminal handler
   - This is CORRECT behavior

---

## Verification Summary

✅ Event routing works correctly
✅ Coordinate conversion works correctly
✅ Selection logic works correctly
✅ Mouse reporting mode works correctly
✅ PTY writing works correctly

⚠️ **suppress_click_to_cursor_once flag is BROKEN**
- Set on focus (line 77, lifecycle.rs)
- Cleared on cursor move (line 7, cursor.rs)
- Suppresses cursor move (line 99-101, terminal_click.rs)
- May not clear before click completes

❌ **No debugging/logging** - impossible to diagnose click issues

---

## Recommended Fixes

### Fix #1: Remove or Fix suppress_click_to_cursor_once Logic

**Option A (Safe)**: Remove the suppression entirely
- Delete line 77 in lifecycle.rs
- Delete lines 99-101 in terminal_click.rs
- Delete field from state.rs:68
- Risk: First click after focus might move cursor incorrectly (but better than NO clicks working)

**Option B (Better)**: Fix the timing
- Clear the flag on MouseInput(Pressed) instead of on CursorMoved
- This ensures it's always cleared by the time Released fires

**Option C (Best)**: Track which click should be suppressed
- Use a counter or timestamp to identify THE specific click that caused focus
- Only suppress that specific click, not "the next click"

### Fix #2: Add Debug Logging

Add debug logging to understand click handling:
- Log when suppress flag is set/cleared
- Log in handle_terminal_left_click: "Handling terminal click at ({}, {})"
- Log when click-to-cursor is executed
- Log when click is suppressed

---

## Self-Critique

### Gaps Found

| Gap | Additional Analysis Needed | Priority |
|-----|---------------------------|----------|
| Exact winit event order not verified empirically | Add logging to see actual event sequence | High |
| Mouse reporting mode transitions not tested | Verify vim/tmux mouse mode doesn't break clicks | Medium |
| Window managers may vary in focus behavior | Test on different platforms/WMs | Low |

### Verification Questions

1. **Completeness of Tracing**: Have I traced ALL execution paths from entry point to final output?
   ✅ YES - Traced from winit event through all handlers to PTY write

2. **File:Line References**: Does every significant code mention include specific file path and line number?
   ✅ YES - All key findings have file:line references

3. **Pattern Identification**: Have I correctly identified design patterns?
   ✅ YES - Event dispatch pattern, state machine for selection, coordinate transformation pipeline

4. **Dependency Mapping**: Have I captured ALL dependencies?
   ✅ YES - winit events → gui handlers → interaction layer → pty layer

5. **Architecture Understanding**: Does my layer mapping accurately reflect actual boundaries?
   ✅ YES - Clear separation between event handling, interaction logic, and PTY I/O
